/**
 * Copyright (C) Metaswitch Networks 2016
 * If license terms are provided to you in a COPYING file in the root directory
 * of the source code repository by which you are accessing this code, then
 * the license outlined in that COPYING file applies to your use.
 * Otherwise no rights are granted except for those provided to you by
 * Metaswitch Networks in a separate written agreement.
*/

/*
 *  Note: this file originally auto-generated by mib2c using
 *        : mib2c.array-user.conf 15997 2007-03-25 22:28:35Z dts12 $
 *
 *  $Id:$
 */

#include "alarm_model_table.hpp"
#include "log.h"

static netsnmp_handler_registration* my_handler = NULL;
static netsnmp_table_array_callbacks cb;
/************************************************************
 *
 *  Initializes the alarmModelTable module (not used in tests)
 */
// LCOV_EXCL_START
void init_alarmModelTable(AlarmTableDefs& defs)
{
  if (initialize_table_alarmModelTable() == SNMP_ERR_NOERROR)
  {
    alarmModelTable_insert_defs(defs);
  }
}
// LCOV_EXCL_STOP

/************************************************************
 *
 * Retreives all the alarm definitions
 */
void alarmModelTable_insert_defs(AlarmTableDefs& defs)
{
  for (AlarmTableDefsIterator it = defs.begin(); it != defs.end(); it++)
  {
    alarmModelTable_context* ctx = alarmModelTable_create_row_context((char*) "", 
                                                                      it->alarm_index(), 
                                                                      it->state());
    if (ctx)
    {
      ctx->_alarm_table_def = &(*it);
      CONTAINER_INSERT(cb.container, ctx);
    }
  }
}

/************************************************************
 *
 *  Initialize the alarmModelTable table by defining its contents
 *  and how it's structured
 */
int initialize_table_alarmModelTable(void)
{
  netsnmp_table_registration_info *table_info;

  if (my_handler)
  {
    // LCOV_EXCL_START
    TRC_ERROR("initialize_table_alarmModelTable called again");
    return SNMP_ERR_NOERROR;
    // LCOV_EXCL_STOP
  }

  memset(&cb, 0x00, sizeof(cb));

  /** create the table structure itself */
  table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);

  if (!table_info)
  {
    // LCOV_EXCL_START
    TRC_ERROR("malloc failed: initialize_table_alarmModelTable");
    return SNMP_ERR_GENERR;
    // LCOV_EXCL_STOP
  }

  my_handler = netsnmp_create_handler_registration("alarmModelTable",
                                                   netsnmp_table_array_helper_handler,
                                                   alarmModelTable_oid,
                                                   alarmModelTable_oid_len,
                                                   HANDLER_CAN_RONLY);
            
  if (!my_handler)
  {
    // LCOV_EXCL_START
    TRC_ERROR("malloc failed: initialize_table_alarmModelTable");
    SNMP_FREE(table_info);
    return SNMP_ERR_GENERR;
    // LCOV_EXCL_STOP
  }

  /*
   * Setting up the table's definition
   */

  /** index: alarmListName */
  netsnmp_table_helper_add_index(table_info, ASN_OCTET_STR);
  /** index: alarmModelIndex */
  netsnmp_table_helper_add_index(table_info, ASN_UNSIGNED);
  /** index: alarmModelState */
  netsnmp_table_helper_add_index(table_info, ASN_UNSIGNED);

  table_info->min_column = alarmModelTable_COL_MIN;
  table_info->max_column = alarmModelTable_COL_MAX;

  /*
   * registering the table with the master agent
   */
  cb.get_value = alarmModelTable_get_value;
  cb.container = netsnmp_container_find("alarmModelTable_primary:"
                                        "alarmModelTable:"
                                        "table_container");
  cb.can_set = 0;

  DEBUGMSGTL(("initialize_table_alarmModelTable", "Registering as table array\n"));

  netsnmp_table_container_register(my_handler, table_info, &cb, cb.container, 1);

  return SNMP_ERR_NOERROR;
}

/************************************************************
 *
 *  This routine is called for get requests to copy the data
 *  from the context to the varbind for the request.
 */
int alarmModelTable_get_value(netsnmp_request_info* request,
                              netsnmp_index* item,
                              netsnmp_table_request_info* table_info)
{
  netsnmp_variable_list* var = request->requestvb;
  alarmModelTable_context* context = (alarmModelTable_context*) item;

  switch(table_info->colnum)
  {
    case COLUMN_ALARMMODELNOTIFICATIONID:
    {
      if (context->_alarm_table_def->severity() == AlarmDef::CLEARED)
      {
        snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                 (u_char*) alarm_clear_state_oid,
                                 sizeof(alarm_clear_state_oid));
      }
      else
      {
        snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                 (u_char*) alarm_active_state_oid,
                                 sizeof(alarm_active_state_oid));
      }
    }
    break;
    // LCOV_EXCL_START 
    case COLUMN_ALARMMODELVARBINDINDEX:
    {
      static unsigned long var_bind_index = 0;
      snmp_set_var_typed_value(var, ASN_UNSIGNED,
                               (u_char*) &var_bind_index,
                               sizeof(var_bind_index));
    }
    break;
    
    case COLUMN_ALARMMODELVARBINDVALUE:
    {
      static unsigned long var_bind_value = 0;
      snmp_set_var_typed_value(var, ASN_INTEGER,
                               (u_char*) &var_bind_value,
                               sizeof(var_bind_value));
    }
    break;
    // LCOV_EXCL_STOP
    case COLUMN_ALARMMODELDESCRIPTION:
    {
      snmp_set_var_typed_value(var, ASN_OCTET_STR,
                               (u_char*) context->_alarm_table_def->description().c_str(),
                               context->_alarm_table_def->description().length());
    }
    break;
    // LCOV_EXCL_START
    case COLUMN_ALARMMODELSPECIFICPOINTER:
    {
      snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                               (u_char*) itu_alarm_table_row_oid,
                               sizeof(itu_alarm_table_row_oid));

      var->val.objid[ITUALARMTABLEROW_INDEX] = context->_alarm_table_def->alarm_index();
      var->val.objid[ITUALARMTABLEROW_SEVERITY] = context->_alarm_table_def->severity();
    }
    break;
    
    case COLUMN_ALARMMODELVARBINDSUBTREE:
    {
      snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                               (u_char*) zero_dot_zero_oid,
                               sizeof(zero_dot_zero_oid));
    }
    break;
    
    case COLUMN_ALARMMODELRESOURCEPREFIX:
    {
      snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                               (u_char*) zero_dot_zero_oid,
                               sizeof(zero_dot_zero_oid));
    }
    break;
    
    case COLUMN_ALARMMODELROWSTATUS:
    {
      static long row_status = ROWSTATUS_ACTIVE;
      snmp_set_var_typed_value(var, ASN_INTEGER,
                               (u_char*) &row_status,
                               sizeof(row_status));
    }
    break;
    // LCOV_EXCL_STOP

    default: /** We shouldn't get here */
    {
      // LCOV_EXCL_START
      TRC_ERROR("unknown column: alarmModelTable_get_value");
      return SNMP_ERR_GENERR;
      // LCOV_EXCL_STOP
    }
  }

  return SNMP_ERR_NOERROR;
}

/************************************************************
 * 
 *  Create a new row context and initialize its oid index.
 */
alarmModelTable_context* alarmModelTable_create_row_context(char* name,
                                                            unsigned long index,
                                                            unsigned long state)
{
  alarmModelTable_context* ctx = SNMP_MALLOC_TYPEDEF(alarmModelTable_context);
  if (!ctx)
  {
    // LCOV_EXCL_START
    TRC_ERROR("malloc failed: alarmModelTable_create_row_context");
    return NULL;
    // LCOV_EXCL_STOP
  }
        
  if (alarmModelTable_index_to_oid(name, index, state, &ctx->_index) != SNMP_ERR_NOERROR)
  {
    // LCOV_EXCL_START
    if (ctx->_index.oids != NULL)
    {
      free(ctx->_index.oids);
    }

    free(ctx);
    return NULL;
    // LCOV_EXCL_STOP
  }

  return ctx;
}

/************************************************************
 *
 *  Convert table index components to an oid.
 */
int alarmModelTable_index_to_oid(char* name,
                                 unsigned long index,
                                 unsigned long state,
                                 netsnmp_index *oid_idx)
{
  int err = SNMP_ERR_NOERROR;

  netsnmp_variable_list var_alarmListName;
  netsnmp_variable_list var_alarmModelIndex;
  netsnmp_variable_list var_alarmModelState;

  /*
   * set up varbinds
   */
  memset(&var_alarmListName, 0x00, sizeof(var_alarmListName));
  var_alarmListName.type = ASN_OCTET_STR;
  memset(&var_alarmModelIndex, 0x00, sizeof(var_alarmModelIndex));
  var_alarmModelIndex.type = ASN_UNSIGNED;
  memset(&var_alarmModelState, 0x00, sizeof(var_alarmModelState));
  var_alarmModelState.type = ASN_UNSIGNED;

  /*
   * chain index varbinds together
   */
  var_alarmListName.next_variable = &var_alarmModelIndex;
  var_alarmModelIndex.next_variable = &var_alarmModelState;
  var_alarmModelState.next_variable =  NULL;


  DEBUGMSGTL(("verbose:alarmModelTable:alarmModelTable_index_to_oid", "called\n"));

  snmp_set_var_value(&var_alarmListName, (u_char*) name, strlen(name));
  snmp_set_var_value(&var_alarmModelIndex, (u_char*) &index, sizeof(index));
  snmp_set_var_value(&var_alarmModelState, (u_char*) &state, sizeof(state));

  err = build_oid(&oid_idx->oids, &oid_idx->len, NULL, 0, &var_alarmListName);
  if (err)
  {
    TRC_ERROR("error %d converting index to oid: alarmModelTable_index_to_oid", err); // LCOV_EXCL_LINE
  }

  /*
   * parsing may have allocated memory. free it.
   */
  snmp_reset_var_buffers(&var_alarmListName);

  return err;
} 

